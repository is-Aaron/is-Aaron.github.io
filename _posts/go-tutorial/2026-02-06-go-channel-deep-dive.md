---
title: Channel æ·±åº¦è§£æï¼šåº•å±‚ç»“æ„ä¸é˜»å¡å”¤é†’æœºåˆ¶
date: 2026-02-06 00:00:00 +0800
categories: [Go å…¥é—¨æ•™ç¨‹, å¹¶å‘ç¼–ç¨‹, Go è¯­è¨€]
tags: [Go, Channel, hchan, å¹¶å‘, select, CSP, Runtime]
mermaid: true
---

> **æ ¸å¿ƒè§‚ç‚¹**ï¼šChannel å¹¶éé­”æ³•â€”â€”å®ƒçš„åº•å±‚æ˜¯ä¸€ä¸ª**å¸¦äº’æ–¥é”çš„ç¯å½¢é˜Ÿåˆ—**åŠ ä¸Š**ä¸¤ä¸ª goroutine ç­‰å¾…é˜Ÿåˆ—**ã€‚ç†è§£ `hchan` çš„å†…å­˜å¸ƒå±€ã€å‘é€/æ¥æ”¶çš„ä¸‰æ¡æ‰§è¡Œè·¯å¾„ã€ä»¥åŠ `gopark`/`goready` çš„é˜»å¡å”¤é†’æœºåˆ¶ï¼Œæ˜¯çœŸæ­£æŒæ¡ Go å¹¶å‘ç¼–ç¨‹çš„é’¥åŒ™ã€‚

## ä¸€ã€Channelï¼šGo å¹¶å‘çš„æ ¸å¿ƒé€šä¿¡åŸè¯­

Go çš„å¹¶å‘å“²å­¦æºè‡ª Tony Hoare åœ¨ 1978 å¹´æå‡ºçš„ **CSPï¼ˆCommunicating Sequential Processesï¼‰** æ¨¡å‹ï¼Œæµ“ç¼©ä¸ºä¸€å¥è¯ï¼š

> *Do not communicate by sharing memory; instead, share memory by communicating.*
>
> ä¸è¦é€šè¿‡å…±äº«å†…å­˜æ¥é€šä¿¡ï¼Œè€Œæ˜¯é€šè¿‡é€šä¿¡æ¥å…±äº«å†…å­˜ã€‚

Channel å°±æ˜¯è¿™å¥è¯çš„ç›´æ¥ä½“ç°ã€‚å®ƒæ˜¯ goroutine ä¹‹é—´ä¼ é€’æ•°æ®å’ŒåŒæ­¥æ‰§è¡Œçš„ç®¡é“ï¼Œæ‰®æ¼”ç€ Go å¹¶å‘ä¸–ç•Œä¸­"ä¿¡ä½¿"çš„è§’è‰²ã€‚

```mermaid
graph LR
    G1["Goroutine A"] -->|"ch <- data"| CH(["Channel"])
    CH -->|"data = <-ch"| G2["Goroutine B"]
    
    style CH fill:#74c0fc,stroke:#1971c2,stroke-width:2px
```

ä¸äº’æ–¥é”ï¼ˆMutexï¼‰ä¸åŒï¼ŒChannel ä¸æ˜¯ä¿æŠ¤å…±äº«èµ„æºçš„"é—¨å«"ï¼Œè€Œæ˜¯æ•°æ®æ‰€æœ‰æƒçš„"è½¬ç§»é€šé“"â€”â€”å½“æ•°æ®é€šè¿‡ Channel å‘é€åï¼Œå‘é€æ–¹ä¸åº”å†è®¿é—®è¯¥æ•°æ®ï¼Œæ¥æ”¶æ–¹è·å¾—ç‹¬å æ‰€æœ‰æƒã€‚

## äºŒã€åŸºç¡€ç”¨æ³•ï¼šä»è¡¨é¢ç†è§£ Channel

### åˆ›å»º Channel

Channel é€šè¿‡å†…ç½®çš„ `make` å‡½æ•°åˆ›å»ºï¼š

```go
ch1 := make(chan int)      // æ— ç¼“å†² Channel
ch2 := make(chan string, 5) // æœ‰ç¼“å†² Channelï¼Œå®¹é‡ä¸º 5
```

### æ— ç¼“å†² vs æœ‰ç¼“å†²

è¿™æ˜¯ç†è§£ Channel è¡Œä¸ºçš„ç¬¬ä¸€é“åˆ†æ°´å²­ï¼š

| ç‰¹æ€§       | æ— ç¼“å†² Channel (`make(chan T)`)          | æœ‰ç¼“å†² Channel (`make(chan T, N)`)           |
| ---------- | ---------------------------------------- | -------------------------------------------- |
| å†…éƒ¨ç¼“å†²åŒº | æ— ï¼ˆå®¹é‡ä¸º 0ï¼‰                           | æœ‰ï¼ˆå®¹é‡ä¸º Nï¼‰                               |
| å‘é€è¡Œä¸º   | é˜»å¡ï¼Œç›´åˆ°æœ‰æ¥æ”¶è€…                       | ç¼“å†²åŒºæœªæ»¡æ—¶ç«‹å³è¿”å›ï¼›æ»¡äº†åˆ™é˜»å¡             |
| æ¥æ”¶è¡Œä¸º   | é˜»å¡ï¼Œç›´åˆ°æœ‰å‘é€è€…                       | ç¼“å†²åŒºéç©ºæ—¶ç«‹å³è¿”å›ï¼›ç©ºäº†åˆ™é˜»å¡             |
| åŒæ­¥è¯­ä¹‰   | **åŒæ­¥**ï¼šå‘é€å’Œæ¥æ”¶å¿…é¡»åŒæ—¶å°±ç»ªï¼ˆæ¡æ‰‹ï¼‰ | **å¼‚æ­¥**ï¼šå‘é€è€…å’Œæ¥æ”¶è€…å¯ä»¥åœ¨ä¸€å®šç¨‹åº¦ä¸Šè§£è€¦ |
| å…¸å‹ç”¨é€”   | ä¿¡å·é€šçŸ¥ã€åŒæ­¥åè°ƒ                       | å‰Šå³°å¡«è°·ã€æ‰¹é‡å¤„ç†                           |

ä¸€ä¸ªç›´è§‚çš„æ¯”å–»ï¼š

- **æ— ç¼“å†² Channel** åƒé¢å¯¹é¢é€’ä¸œè¥¿â€”â€”ä½ ä¼¸å‡ºæ‰‹ï¼Œå¯¹æ–¹å¿…é¡»åŒæ—¶ä¼¸æ‰‹æ¥ä½ï¼Œå¦åˆ™åŒæ–¹éƒ½å¾—ç­‰ç€ã€‚
- **æœ‰ç¼“å†² Channel** åƒä¼ é€å¸¦â€”â€”ä½ å¯ä»¥å…ˆæŠŠä¸œè¥¿æ”¾ä¸Šå»å°±èµ°ï¼Œå¯¹æ–¹éšåæ¥å–ï¼›ä½†ä¼ é€å¸¦æ»¡äº†ï¼Œä½ ä¹Ÿå¾—ç­‰ã€‚

### åŸºæœ¬æ“ä½œ

```go
// å‘é€
ch <- 42

// æ¥æ”¶
v := <-ch

// æ¥æ”¶å¹¶æ£€æŸ¥ Channel æ˜¯å¦å…³é—­
v, ok := <-ch  // ok ä¸º false è¡¨ç¤º Channel å·²å…³é—­ä¸”ç¼“å†²åŒºä¸ºç©º

// å…³é—­ Channel
close(ch)

// éå† Channelï¼ˆç›´åˆ°å…³é—­ï¼‰
for v := range ch {
    fmt.Println(v)
}
```

çœ‹ä¸Šå»å¾ˆç®€å•ï¼Ÿé‚£æˆ‘ä»¬ç°åœ¨å°±æ­å¼€è¡¨é¢ï¼Œçœ‹çœ‹è¿™äº›æ“ä½œèƒŒååˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆã€‚

## ä¸‰ã€hchanï¼šæ­å¼€ Channel çš„åº•å±‚é¢çº±

å½“ä½ å†™ä¸‹ `make(chan int, 5)` æ—¶ï¼ŒGo Runtime ä¼šè°ƒç”¨ `runtime.makechan` å‡½æ•°ï¼Œåœ¨**å †**ä¸Šåˆ†é…ä¸€ä¸ª `hchan` ç»“æ„ä½“ã€‚æ‰€æœ‰ Channel çš„è¡Œä¸ºï¼Œéƒ½å›´ç»•è¿™ä¸ªç»“æ„ä½“å±•å¼€ã€‚

### hchan ç»“æ„ä½“

ä»¥ä¸‹æ˜¯ `hchan` çš„æ ¸å¿ƒå­—æ®µï¼ˆæºç ä½äº `runtime/chan.go`ï¼‰ï¼š

```go
type hchan struct {
    qcount   uint           // ç¼“å†²åŒºä¸­å½“å‰çš„å…ƒç´ ä¸ªæ•°
    dataqsiz uint           // ç¼“å†²åŒºå®¹é‡ï¼ˆå³ make æ—¶æŒ‡å®šçš„ sizeï¼‰
    buf      unsafe.Pointer // æŒ‡å‘ç¯å½¢ç¼“å†²åŒºçš„æŒ‡é’ˆ
    elemsize uint16         // å•ä¸ªå…ƒç´ çš„å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    closed   uint32         // å…³é—­æ ‡å¿—ï¼ˆ0=æœªå…³é—­ï¼Œ1=å·²å…³é—­ï¼‰
    elemtype *_type         // å…ƒç´ ç±»å‹ä¿¡æ¯ï¼ˆç”¨äºæ•°æ®æ‹·è´å’Œ GCï¼‰
    sendx    uint           // ä¸‹ä¸€æ¬¡å‘é€çš„ä½ç½®ï¼ˆç¯å½¢ç´¢å¼•ï¼‰
    recvx    uint           // ä¸‹ä¸€æ¬¡æ¥æ”¶çš„ä½ç½®ï¼ˆç¯å½¢ç´¢å¼•ï¼‰
    recvq    waitq          // ç­‰å¾…æ¥æ”¶çš„ goroutine é˜Ÿåˆ—
    sendq    waitq          // ç­‰å¾…å‘é€çš„ goroutine é˜Ÿåˆ—
    lock     mutex          // ä¿æŠ¤ hchan æ‰€æœ‰å­—æ®µçš„äº’æ–¥é”
}
```

æ¯ä¸ªå­—æ®µéƒ½æœ‰æ˜ç¡®çš„èŒè´£ï¼Œç»„åˆèµ·æ¥æ„æˆäº† Channel çš„å®Œæ•´è¿è¡Œæ—¶çŠ¶æ€ï¼š

```mermaid
graph TB
    subgraph hchan[" hchan ç»“æ„ä½“ "]
        direction TB
        
        subgraph Control[" æ§åˆ¶ä¿¡æ¯ "]
            closed["closed: å…³é—­æ ‡å¿—"]
            lock["lock: äº’æ–¥é”"]
            elemtype["elemtype: å…ƒç´ ç±»å‹"]
            elemsize["elemsize: å…ƒç´ å¤§å°"]
        end
        
        subgraph RingBuf[" ç¯å½¢ç¼“å†²åŒº "]
            buf["buf â†’ [ A | B | C | _ | _ ]"]
            qcount["qcount = 3"]
            dataqsiz["dataqsiz = 5"]
            sendx["sendx = 3 (ä¸‹æ¬¡å†™å…¥ä½ç½®)"]
            recvx["recvx = 0 (ä¸‹æ¬¡è¯»å–ä½ç½®)"]
        end
        
        subgraph WaitQ[" ç­‰å¾…é˜Ÿåˆ— "]
            recvq["recvq: ç­‰å¾…æ¥æ”¶çš„ goroutine é“¾è¡¨"]
            sendq["sendq: ç­‰å¾…å‘é€çš„ goroutine é“¾è¡¨"]
        end
    end
    
    style RingBuf fill:#e7f5ff
    style WaitQ fill:#fff3bf
    style Control fill:#f3f0ff
```

### ç¯å½¢ç¼“å†²åŒº

æœ‰ç¼“å†² Channel çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ª**ç¯å½¢é˜Ÿåˆ—ï¼ˆRing Bufferï¼‰**ï¼Œç”± `buf` æŒ‡å‘çš„è¿ç»­å†…å­˜å—å®ç°ï¼š

```mermaid
graph LR
    subgraph RingBuffer[" ç¯å½¢ç¼“å†²åŒº (dataqsiz=5) "]
        direction LR
        S0["[0] A"]
        S1["[1] B"]
        S2["[2] C"]
        S3["[3] _"]
        S4["[4] _"]
    end
    
    recvx["recvx=0"] -.->|"ä¸‹æ¬¡ä»è¿™é‡Œè¯»"| S0
    sendx["sendx=3"] -.->|"ä¸‹æ¬¡å¾€è¿™é‡Œå†™"| S3
    
    style S0 fill:#a5d8ff
    style S1 fill:#a5d8ff
    style S2 fill:#a5d8ff
    style S3 fill:#f8f9fa,stroke-dasharray: 5 5
    style S4 fill:#f8f9fa,stroke-dasharray: 5 5
```

å·¥ä½œæ–¹å¼ï¼š

- **å†™å…¥**ï¼šå°†æ•°æ®æ‹·è´åˆ° `buf[sendx]`ï¼Œç„¶å `sendx = (sendx + 1) % dataqsiz`ï¼Œ`qcount++`
- **è¯»å–**ï¼šä» `buf[recvx]` æ‹·è´æ•°æ®ï¼Œç„¶å `recvx = (recvx + 1) % dataqsiz`ï¼Œ`qcount--`
- **åˆ¤æ»¡**ï¼š`qcount == dataqsiz`
- **åˆ¤ç©º**ï¼š`qcount == 0`

å½“ç´¢å¼•åˆ°è¾¾æœ«å°¾æ—¶è‡ªåŠ¨ç»•å›èµ·å§‹ä½ç½®ï¼Œå½¢æˆ"ç¯å½¢"æ•ˆæœã€‚å¯¹äº**æ— ç¼“å†² Channel**ï¼Œ`dataqsiz = 0`ï¼Œ`buf` ä¸åˆ†é…å†…å­˜ã€‚

### ç­‰å¾…é˜Ÿåˆ—ä¸ sudog

å½“ goroutine å›  Channel æ“ä½œè€Œé˜»å¡æ—¶ï¼Œå®ƒä¼šè¢«åŒ…è£…æˆä¸€ä¸ª `sudog` ç»“æ„ä½“ï¼ŒæŒ‚åˆ°å¯¹åº”çš„ç­‰å¾…é˜Ÿåˆ—ä¸Šï¼š

```go
type waitq struct {
    first *sudog    // é˜Ÿåˆ—å¤´
    last  *sudog    // é˜Ÿåˆ—å°¾
}

type sudog struct {
    g     *g              // è¢«é˜»å¡çš„ goroutine
    next  *sudog          // é“¾è¡¨ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    prev  *sudog          // é“¾è¡¨ä¸Šä¸€ä¸ªèŠ‚ç‚¹
    elem  unsafe.Pointer  // æŒ‡å‘å‘é€/æ¥æ”¶çš„æ•°æ®
    c     *hchan          // æ‰€å±çš„ Channel
    // ... å…¶ä»–å­—æ®µ
}
```

`sudog` æ˜¯ goroutine ä¸ Channel ä¹‹é—´çš„"è¿æ¥å™¨"â€”â€”å®ƒåŒæ—¶è®°å½•äº†æ˜¯å“ªä¸ª goroutine åœ¨ç­‰å¾…ï¼Œä»¥åŠå®ƒè¦å‘é€/æ¥æ”¶çš„æ•°æ®åœ¨å“ªé‡Œã€‚

```mermaid
graph LR
    subgraph sendq[" sendq (å‘é€ç­‰å¾…é˜Ÿåˆ—) "]
        direction LR
        SG1["sudog<br/>g: G7<br/>elem: &data1"] --> SG2["sudog<br/>g: G12<br/>elem: &data2"]
    end
    
    subgraph recvq[" recvq (æ¥æ”¶ç­‰å¾…é˜Ÿåˆ—) "]
        direction LR
        RG1["sudog<br/>g: G3<br/>elem: &buf"]
    end
    
    style SG1 fill:#ffc9c9
    style SG2 fill:#ffc9c9
    style RG1 fill:#b2f2bb
```

### makechanï¼šChannel çš„å†…å­˜åˆ†é…ç­–ç•¥

`runtime.makechan` æ ¹æ®å…ƒç´ ç±»å‹é‡‡å–ä¸åŒçš„åˆ†é…ç­–ç•¥ï¼š

| åœºæ™¯                  | åˆ†é…æ–¹å¼                              | åŸå›                             |
| --------------------- | ------------------------------------- | ------------------------------- |
| æ— ç¼“å†² / å…ƒç´ å¤§å°ä¸º 0 | ä»…åˆ†é… `hchan` æœ¬èº«                   | ä¸éœ€è¦ç¼“å†²åŒº                    |
| å…ƒç´ ä¸å«æŒ‡é’ˆ          | **ä¸€æ¬¡åˆ†é…** `hchan` + `buf` è¿ç»­å†…å­˜ | GC æ— éœ€æ‰«æ bufï¼Œåˆå¹¶åˆ†é…æ›´é«˜æ•ˆ |
| å…ƒç´ åŒ…å«æŒ‡é’ˆ          | **ä¸¤æ¬¡åˆ†é…** `hchan` å’Œ `buf` åˆ†å¼€    | GC éœ€è¦å•ç‹¬æ‰«æ buf ä¸­çš„æŒ‡é’ˆ    |

è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„è¿è¡Œæ—¶ä¼˜åŒ–ï¼šå‡å°‘å†…å­˜åˆ†é…æ¬¡æ•°ï¼ŒåŒæ—¶é…åˆ GC çš„æ‰«æç­–ç•¥ã€‚

## å››ã€å‘é€æ“ä½œå…¨æµç¨‹ï¼šch <- v

å½“æ‰§è¡Œ `ch <- v` æ—¶ï¼Œç¼–è¯‘å™¨å°†å…¶è½¬æ¢ä¸º `runtime.chansend` è°ƒç”¨ã€‚æ•´ä¸ªå‘é€æµç¨‹åˆ†ä¸º**ä¸‰æ¡è·¯å¾„**ï¼Œä¼˜å…ˆçº§ä»é«˜åˆ°ä½ï¼š

```mermaid
flowchart TD
    Start["ch <- v"] --> NilCheck{"ch == nil?"}
    NilCheck -->|"æ˜¯"| Block1["æ°¸ä¹…é˜»å¡<br/>(gopark)"]
    NilCheck -->|"å¦"| Lock["åŠ é” lock(&c.lock)"]
    Lock --> ClosedCheck{"c.closed != 0?"}
    ClosedCheck -->|"æ˜¯"| Panic["panic:<br/>send on closed channel"]
    ClosedCheck -->|"å¦"| Path1{"recvq æœ‰<br/>ç­‰å¾…çš„æ¥æ”¶è€…?"}
    
    Path1 -->|"æ˜¯"| DirectSend["è·¯å¾„ä¸€ï¼šç›´æ¥å‘é€<br/>æ•°æ®æ‹·è´åˆ°æ¥æ”¶è€…<br/>å”¤é†’æ¥æ”¶è€…"]
    
    Path1 -->|"å¦"| Path2{"ç¼“å†²åŒºæœ‰ç©ºä½?<br/>qcount < dataqsiz"}
    Path2 -->|"æ˜¯"| BufSend["è·¯å¾„äºŒï¼šå†™å…¥ç¼“å†²åŒº<br/>æ‹·è´åˆ° buf[sendx]<br/>sendx++, qcount++"]
    
    Path2 -->|"å¦"| Path3["è·¯å¾„ä¸‰ï¼šé˜»å¡ç­‰å¾…<br/>åˆ›å»º sudog<br/>æŒ‚å…¥ sendq<br/>gopark è®©å‡º CPU"]
    
    DirectSend --> Unlock["è§£é” è¿”å›"]
    BufSend --> Unlock
    Path3 --> Wakeup["è¢«å”¤é†’åè¿”å›"]
    
    style DirectSend fill:#b2f2bb
    style BufSend fill:#a5d8ff
    style Path3 fill:#ffc9c9
    style Panic fill:#ff6b6b,color:#fff
    style Block1 fill:#868e96,color:#fff
```

### è·¯å¾„ä¸€ï¼šç›´æ¥å‘é€ï¼ˆæœ€å¿«è·¯å¾„ï¼‰

**æ¡ä»¶**ï¼š`recvq` ä¸­æœ‰æ­£åœ¨ç­‰å¾…çš„æ¥æ”¶è€…ã€‚

è¿™æ˜¯æœ€é«˜æ•ˆçš„æƒ…å†µâ€”â€”æœ‰ä¸€ä¸ª goroutine å·²ç»åœ¨ç­‰ç€æ”¶æ•°æ®äº†ã€‚Runtime ä¼šåšä¸€ä»¶ç²¾å¦™çš„äº‹ï¼š

```mermaid
sequenceDiagram
    participant Sender as å‘é€è€… G1
    participant RT as Runtime
    participant Receiver as æ¥æ”¶è€… G2 (å·²é˜»å¡)
    
    Note over Receiver: æ­£åœ¨ recvq ä¸­ç­‰å¾…
    Sender->>RT: ch <- data
    RT->>RT: ä» recvq å–å‡º G2 çš„ sudog
    RT->>Receiver: sendDirect: å°†æ•°æ®ç›´æ¥<br/>æ‹·è´åˆ° G2 çš„æ ˆå†…å­˜
    RT->>RT: goready(G2) å”¤é†’ G2
    Note over Sender: ç«‹å³è¿”å›
    Note over Receiver: è¢«å”¤é†’ï¼Œæ•°æ®å·²å°±ç»ª
```

**å…³é”®ç»†èŠ‚**ï¼šæ•°æ®æ˜¯é€šè¿‡ `sendDirect` **ç›´æ¥ä»å‘é€è€…çš„æ ˆæ‹·è´åˆ°æ¥æ”¶è€…çš„æ ˆ**ï¼Œå®Œå…¨ç»•è¿‡äº†ç¼“å†²åŒºã€‚è¿™æ„å‘³ç€ï¼š

1. å³ä½¿æ˜¯æœ‰ç¼“å†² Channelï¼Œå¦‚æœç¼“å†²åŒºä¸ºç©ºä¸”æœ‰æ¥æ”¶è€…åœ¨ç­‰å¾…ï¼Œä¹Ÿèµ°ç›´æ¥å‘é€è·¯å¾„
2. è¿™æ˜¯ä¸€æ¬¡**è·¨ goroutine çš„æ ˆå†…å­˜å†™å…¥**â€”â€”Go Runtime å¯ä»¥è¿™ä¹ˆåšï¼Œå› ä¸ºæ¥æ”¶è€…æ­¤æ—¶å¤„äº parked çŠ¶æ€ï¼Œå…¶æ ˆä¸ä¼šç§»åŠ¨

### è·¯å¾„äºŒï¼šå†™å…¥ç¼“å†²åŒº

**æ¡ä»¶**ï¼š`recvq` ä¸ºç©ºï¼Œä¸”ç¼“å†²åŒºæœªæ»¡ï¼ˆ`qcount < dataqsiz`ï¼‰ã€‚

è¿™æ˜¯æœ‰ç¼“å†² Channel çš„å¸¸è§„è·¯å¾„ï¼š

```go
// ä¼ªä»£ç 
qp := chanbuf(c, c.sendx)     // è®¡ç®— buf[sendx] çš„åœ°å€
typedmemmove(c.elemtype, qp, ep) // å°†æ•°æ®æ‹·è´åˆ°ç¼“å†²åŒº
c.sendx++
if c.sendx == c.dataqsiz {
    c.sendx = 0                // ç¯å½¢ç»•å›
}
c.qcount++
unlock(&c.lock)
```

æ•°æ®è¢«æ‹·è´åˆ°ç¯å½¢ç¼“å†²åŒºçš„ä¸‹ä¸€ä¸ªå¯å†™ä½ç½®ï¼Œå‘é€è€…ç«‹å³è¿”å›ã€‚æ³¨æ„è¿™é‡Œæ˜¯**å€¼æ‹·è´**â€”â€”Channel ä¼ é€’çš„æ°¸è¿œæ˜¯æ•°æ®çš„å‰¯æœ¬ã€‚

### è·¯å¾„ä¸‰ï¼šé˜»å¡ç­‰å¾…

**æ¡ä»¶**ï¼šæ— ç­‰å¾…çš„æ¥æ”¶è€…ï¼Œä¸”ç¼“å†²åŒºå·²æ»¡ï¼ˆæˆ–æ— ç¼“å†² Channelï¼‰ã€‚

å‘é€è€…æ— å¤„å®‰æ”¾æ•°æ®ï¼Œåªèƒ½é˜»å¡è‡ªå·±ï¼š

```go
// ä¼ªä»£ç 
mysg := acquireSudog()        // ä»ç¼“å­˜æ± è·å– sudog
mysg.elem = ep                // è®°å½•è¦å‘é€çš„æ•°æ®åœ°å€
mysg.g = getg()               // è®°å½•å½“å‰ goroutine
c.sendq.enqueue(mysg)         // æŒ‚å…¥å‘é€ç­‰å¾…é˜Ÿåˆ—
gopark(...)                   // è®©å‡º CPUï¼Œåˆ‡æ¢åˆ°å…¶ä»– goroutine
// ---- æ­¤å¤„æš‚åœæ‰§è¡Œï¼Œç›´åˆ°è¢«å”¤é†’ ----
releaseSudog(mysg)            // å”¤é†’åï¼Œé‡Šæ”¾ sudog
```

å…³é”®è¦ç‚¹ï¼š`sudog.elem` ä¿å­˜çš„æ˜¯**å‘é€æ•°æ®çš„æŒ‡é’ˆ**ã€‚å½“æ¥æ”¶è€…åˆ°æ¥æ—¶ï¼Œå¯ä»¥ç›´æ¥ä»è¿™ä¸ªåœ°å€æ‹·è´æ•°æ®ï¼Œè€Œæ— éœ€å‘é€è€…å‚ä¸â€”â€”å› ä¸ºå‘é€è€…æ­¤æ—¶æ ¹æœ¬ä¸åœ¨è¿è¡Œã€‚

## äº”ã€æ¥æ”¶æ“ä½œå…¨æµç¨‹ï¼šv = <- ch

æ¥æ”¶æ“ä½œç”± `runtime.chanrecv` å®ç°ï¼ŒåŒæ ·æœ‰ä¸‰æ¡è·¯å¾„ï¼š

```mermaid
flowchart TD
    Start["v = <- ch"] --> NilCheck{"ch == nil?"}
    NilCheck -->|"æ˜¯"| Block1["æ°¸ä¹…é˜»å¡"]
    NilCheck -->|"å¦"| Lock["åŠ é”"]
    Lock --> ClosedEmpty{"å·²å…³é—­ ä¸”<br/>ç¼“å†²åŒºä¸ºç©º?"}
    ClosedEmpty -->|"æ˜¯"| ZeroVal["è¿”å›é›¶å€¼<br/>ok = false"]
    ClosedEmpty -->|"å¦"| Path1{"sendq æœ‰<br/>ç­‰å¾…çš„å‘é€è€…?"}
    
    Path1 -->|"æ˜¯"| DirectRecv["è·¯å¾„ä¸€ï¼šç›´æ¥æ¥æ”¶"]
    
    Path1 -->|"å¦"| Path2{"ç¼“å†²åŒºæœ‰æ•°æ®?<br/>qcount > 0"}
    Path2 -->|"æ˜¯"| BufRecv["è·¯å¾„äºŒï¼šä»ç¼“å†²åŒºè¯»å–"]
    
    Path2 -->|"å¦"| Path3["è·¯å¾„ä¸‰ï¼šé˜»å¡ç­‰å¾…<br/>åˆ›å»º sudog<br/>æŒ‚å…¥ recvq<br/>gopark"]
    
    DirectRecv --> Unlock["è§£é” è¿”å›"]
    BufRecv --> Unlock
    Path3 --> Wakeup["è¢«å”¤é†’åè¿”å›"]
    
    style DirectRecv fill:#b2f2bb
    style BufRecv fill:#a5d8ff
    style Path3 fill:#ffc9c9
    style ZeroVal fill:#868e96,color:#fff
```

### è·¯å¾„ä¸€ï¼šç›´æ¥æ¥æ”¶ï¼ˆsendq æœ‰ç­‰å¾…è€…ï¼‰

**æ¡ä»¶**ï¼š`sendq` ä¸­æœ‰æ­£åœ¨ç­‰å¾…çš„å‘é€è€…ã€‚

è¿™ç§æƒ…å†µæ„å‘³ç€ï¼š

- **æ— ç¼“å†² Channel**ï¼šç›´æ¥ä»å‘é€è€…çš„æ ˆæ‹·è´æ•°æ®åˆ°æ¥æ”¶è€…ï¼ˆä¸å‘é€è·¯å¾„ä¸€å¯¹ç§°ï¼‰
- **æœ‰ç¼“å†² Channel**ï¼šæ­¤æ—¶ç¼“å†²åŒº**å¿…ç„¶å·²æ»¡**ï¼ˆå¦åˆ™å‘é€è€…ä¸ä¼šé˜»å¡ï¼‰ã€‚éœ€è¦æ‰§è¡Œä¸€ä¸ªç²¾å·§çš„ä¸¤æ­¥æ“ä½œï¼š

```mermaid
sequenceDiagram
    participant Receiver as æ¥æ”¶è€… G3
    participant Buf as ç¯å½¢ç¼“å†²åŒº
    participant Sender as å‘é€è€… G7 (å·²é˜»å¡)
    
    Note over Buf: ç¼“å†²åŒºå·²æ»¡ [D|E|F]
    Note over Sender: åœ¨ sendq ä¸­ç­‰å¾…å‘é€æ•°æ®
    
    Receiver->>Buf: â‘  ä» buf[recvx] è¯»å‡º D
    Receiver->>Receiver: è·å¾—æ•°æ® D
    Sender-->>Buf: â‘¡ å°†å‘é€è€…çš„æ•°æ®å†™å…¥ buf[recvx]<br/>(åˆšè…¾å‡ºçš„ä½ç½®)
    Note over Buf: ç¼“å†²åŒºä»ç„¶æ»¡ [æ–°æ•°æ®|E|F]<br/>ä½†å†…å®¹å·²è½®è½¬
    Receiver->>Sender: â‘¢ goready(G7) å”¤é†’å‘é€è€…
```

**ä¸ºä»€ä¹ˆæœ‰ç¼“å†² Channel ä¸èƒ½ç›´æ¥ä»å‘é€è€…æ‹·è´ï¼Ÿ** å› ä¸ºç¼“å†²åŒºé‡Œè¿˜æœ‰æ›´æ—©çš„æ•°æ®ç­‰ç€è¢«è¯»ï¼Œå¿…é¡»ç»´æŠ¤ FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰é¡ºåºã€‚æ‰€ä»¥å…ˆè¯»ç¼“å†²åŒºå¤´éƒ¨çš„æ—§æ•°æ®ç»™æ¥æ”¶è€…ï¼Œå†æŠŠå‘é€è€…çš„æ–°æ•°æ®æ”¾åˆ°ç¼“å†²åŒºä¸­ã€‚

### è·¯å¾„äºŒï¼šä»ç¼“å†²åŒºè¯»å–

**æ¡ä»¶**ï¼š`sendq` ä¸ºç©ºï¼Œç¼“å†²åŒºæœ‰æ•°æ®ï¼ˆ`qcount > 0`ï¼‰ã€‚

```go
// ä¼ªä»£ç 
qp := chanbuf(c, c.recvx)         // è®¡ç®— buf[recvx] çš„åœ°å€
typedmemmove(c.elemtype, ep, qp)   // æ‹·è´æ•°æ®åˆ°æ¥æ”¶è€…
typedmemclr(c.elemtype, qp)        // æ¸…é›¶ç¼“å†²åŒºæ§½ä½ï¼ˆå¸®åŠ© GCï¼‰
c.recvx++
if c.recvx == c.dataqsiz {
    c.recvx = 0                    // ç¯å½¢ç»•å›
}
c.qcount--
unlock(&c.lock)
```

æ³¨æ„ `typedmemclr` æ“ä½œï¼šè¯»å–åä¼šå°†ç¼“å†²åŒºå¯¹åº”ä½ç½®æ¸…é›¶ã€‚è¿™ä¸æ˜¯ä¸ºäº†æ­£ç¡®æ€§ï¼Œè€Œæ˜¯ä¸ºäº†å¸®åŠ© GCâ€”â€”å¦‚æœå…ƒç´ åŒ…å«æŒ‡é’ˆï¼Œæ¸…é›¶å¯ä»¥è®© GC çŸ¥é“è¿™ä¸ªä½ç½®ä¸å†å¼•ç”¨ä»»ä½•å¯¹è±¡ï¼Œé¿å…å†…å­˜æ³„æ¼ã€‚

### è·¯å¾„ä¸‰ï¼šé˜»å¡ç­‰å¾…

**æ¡ä»¶**ï¼šæ— ç­‰å¾…çš„å‘é€è€…ï¼Œç¼“å†²åŒºä¸ºç©ºã€‚

ä¸å‘é€çš„è·¯å¾„ä¸‰å¯¹ç§°ï¼šåˆ›å»º sudogï¼ŒæŒ‚å…¥ `recvq`ï¼Œè°ƒç”¨ `gopark` é˜»å¡å½“å‰ goroutineã€‚

## å…­ã€é˜»å¡ä¸å”¤é†’çš„æœ¬è´¨ï¼šgopark ä¸ goready

Channel ä¹‹æ‰€ä»¥èƒ½å®ç°"å‘ä¸å‡ºå»å°±ç­‰ç€ï¼Œæ”¶ä¸åˆ°å°±ç­‰ç€"çš„è¡Œä¸ºï¼Œæ ¸å¿ƒä¾èµ–äº Go Runtime è°ƒåº¦å™¨æä¾›çš„ä¸¤ä¸ªåŸè¯­ã€‚

### goparkï¼šè®©å‡º CPU

å½“ goroutine éœ€è¦é˜»å¡æ—¶ï¼ŒRuntime è°ƒç”¨ `gopark`ï¼š

```go
// ä¼ªä»£ç ï¼šgopark çš„æ ¸å¿ƒé€»è¾‘
func gopark(unlockf func(), reason waitReason) {
    gp := getg()              // è·å–å½“å‰ goroutine
    gp.status = _Gwaiting     // çŠ¶æ€ï¼šè¿è¡Œä¸­ â†’ ç­‰å¾…ä¸­
    gp.waitreason = reason    // è®°å½•ç­‰å¾…åŸå› ï¼ˆå¦‚ "chan send"ï¼‰
    unlockf()                 // é‡Šæ”¾ Channel çš„é”
    schedule()                // è°ƒç”¨è°ƒåº¦å™¨ï¼Œåˆ‡æ¢åˆ°å…¶ä»– goroutine
    // ---- æ­¤å¤„ä¸ä¼šç»§ç»­æ‰§è¡Œï¼Œç›´åˆ°è¢« goready å”¤é†’ ----
}
```

å…³é”®ç‚¹ï¼š

1. goroutine çŠ¶æ€ä» `_Grunning` å˜ä¸º `_Gwaiting`ï¼Œ**ä¸å†å‚ä¸è°ƒåº¦**ï¼ˆè¿è¡Œä¸­çš„ G æœ¬å°±ä¸åœ¨è¿è¡Œé˜Ÿåˆ—ä¸­ï¼Œæ­¤æ—¶è½¬ä¸ºç­‰å¾…çŠ¶æ€ï¼Œç›´åˆ°è¢«å”¤é†’ï¼‰
2. é‡Šæ”¾ Channel çš„é”ï¼ˆè¿™ä¸ªé¡ºåºå¾ˆé‡è¦â€”â€”å…ˆè®¾å¥½çŠ¶æ€ï¼Œå†é‡Šæ”¾é”ï¼Œé˜²æ­¢ç«æ€ï¼‰
3. è°ƒç”¨ `schedule()` è®©å½“å‰çº¿ç¨‹ï¼ˆMï¼‰å»æ‰§è¡Œåˆ«çš„ goroutine

### goreadyï¼šé‡æ–°è°ƒåº¦

å½“å¦ä¸€ç«¯çš„ goroutine åˆ°æ¥ï¼Œéœ€è¦å”¤é†’ç­‰å¾…è€…æ—¶ï¼ŒRuntime è°ƒç”¨ `goready`ï¼š

```go
// ä¼ªä»£ç ï¼šgoready çš„æ ¸å¿ƒé€»è¾‘
func goready(gp *g) {
    gp.status = _Grunnable    // çŠ¶æ€ï¼šç­‰å¾…ä¸­ â†’ å¯è¿è¡Œ
    runqput(getg().m.p, gp)   // æ”¾å…¥å½“å‰ P çš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—
    wakep()                   // å¦‚æœæœ‰ç©ºé—²çš„ Pï¼Œå”¤é†’å®ƒ
}
```

å…³é”®ç‚¹ï¼š

1. goroutine çŠ¶æ€ä» `_Gwaiting` å˜ä¸º `_Grunnable`
2. è¢«æ”¾å›è°ƒåº¦å™¨çš„è¿è¡Œé˜Ÿåˆ—ï¼Œç­‰å¾…è¢«æŸä¸ªçº¿ç¨‹ï¼ˆMï¼‰æ‰§è¡Œ
3. `goready` å¹¶ä¸ç«‹å³æ‰§è¡Œè¢«å”¤é†’çš„ goroutineâ€”â€”å®ƒåªæ˜¯æŠŠå®ƒæ ‡è®°ä¸º"å¯è¿è¡Œ"

### å®Œæ•´çš„é˜»å¡-å”¤é†’æ—¶åº

ä»¥ä¸€æ¬¡æ— ç¼“å†² Channel é€šä¿¡ä¸ºä¾‹ï¼Œçœ‹å®Œæ•´çš„æµç¨‹ï¼š

```mermaid
sequenceDiagram
    participant G1 as Goroutine 1 (æ¥æ”¶æ–¹)
    participant CH as Channel (hchan)
    participant Sched as è°ƒåº¦å™¨
    participant G2 as Goroutine 2 (å‘é€æ–¹)
    
    Note over G1: æ‰§è¡Œ v := <-ch
    G1->>CH: lock()
    G1->>CH: sendq ä¸ºç©ºï¼Œç¼“å†²åŒºä¸ºç©º
    G1->>CH: åˆ›å»º sudogï¼ŒæŒ‚å…¥ recvq
    G1->>Sched: gopark â†’ çŠ¶æ€å˜ä¸º _Gwaiting
    Note over G1: ğŸ’¤ é˜»å¡ä¸­...
    
    Note over Sched: G1 ä»è¿è¡Œé˜Ÿåˆ—ç§»é™¤<br/>è°ƒåº¦å…¶ä»– goroutine
    
    Note over G2: ç¨åæ‰§è¡Œ ch <- 42
    G2->>CH: lock()
    G2->>CH: recvq æœ‰ç­‰å¾…è€… â†’ å–å‡º G1 çš„ sudog
    G2->>G1: sendDirect: å°† 42 æ‹·è´åˆ° G1 çš„æ ˆ
    G2->>CH: unlock() ï¼ˆæ‹·è´å®Œæˆåç«‹å³é‡Šæ”¾é”ï¼‰
    G2->>Sched: goready(G1) â†’ çŠ¶æ€å˜ä¸º _Grunnable
    Note over G2: å‘é€å®Œæˆï¼Œç»§ç»­æ‰§è¡Œ
    
    Sched->>G1: è°ƒåº¦æ‰§è¡Œ G1
    Note over G1: ğŸŒ… è¢«å”¤é†’ï¼Œv = 42
```

æ•´ä¸ªè¿‡ç¨‹ä¸­çš„**é”æŒæœ‰æ—¶é—´éå¸¸çŸ­**â€”â€”åªåœ¨æ“ä½œ hchan å­—æ®µæ—¶æŒé”ï¼Œæ•°æ®æ‹·è´å®Œæˆåç«‹åˆ»é‡Šæ”¾ã€‚è¿™æ˜¯ Channel é«˜æ•ˆçš„å…³é”®ä¹‹ä¸€ã€‚

## ä¸ƒã€å…³é—­ Channelï¼šclose(ch)

### close çš„æ‰§è¡Œæµç¨‹

`runtime.closechan` çš„æ ¸å¿ƒé€»è¾‘ï¼š

```mermaid
flowchart TD
    Start["close(ch)"] --> NilCheck{"ch == nil?"}
    NilCheck -->|"æ˜¯"| P1["panic: close of nil channel"]
    NilCheck -->|"å¦"| Lock["åŠ é”"]
    Lock --> ClosedCheck{"å·²ç»å…³é—­?"}
    ClosedCheck -->|"æ˜¯"| P2["panic: close of closed channel"]
    ClosedCheck -->|"å¦"| SetFlag["è®¾ç½® c.closed = 1"]
    
    SetFlag --> WakeRecv["å”¤é†’ recvq ä¸­æ‰€æœ‰ç­‰å¾…è€…<br/>å®ƒä»¬å°†æ”¶åˆ°é›¶å€¼, ok=false"]
    WakeRecv --> WakeSend["å”¤é†’ sendq ä¸­æ‰€æœ‰ç­‰å¾…è€…<br/>å®ƒä»¬å°†è§¦å‘ panic"]
    WakeSend --> Unlock["è§£é”"]
    
    style P1 fill:#ff6b6b,color:#fff
    style P2 fill:#ff6b6b,color:#fff
    style WakeRecv fill:#b2f2bb
    style WakeSend fill:#ffc9c9
```

æ³¨æ„ä¸¤ä¸ªå…³é”®è¡Œä¸ºï¼š

1. **ç­‰å¾…æ¥æ”¶çš„ goroutine** è¢«å”¤é†’åï¼Œæ”¶åˆ°ç±»å‹é›¶å€¼ï¼Œ`ok` æ ‡å¿—ä¸º `false`
2. **ç­‰å¾…å‘é€çš„ goroutine** è¢«å”¤é†’åï¼Œæ£€æµ‹åˆ° Channel å·²å…³é—­ï¼Œè§¦å‘ `panic`

### è¾¹ç•Œè¡Œä¸ºæ€»ç»“

Channel åœ¨ä¸åŒçŠ¶æ€ä¸‹çš„æ“ä½œç»“æœï¼Œæ˜¯é¢è¯•é«˜é¢‘è€ƒç‚¹ï¼š

| æ“ä½œ      | nil Channel  | å·²å…³é—­ Channel                     | æ­£å¸¸ Channel   |
| --------- | ------------ | ---------------------------------- | -------------- |
| `ch <- v` | **æ°¸ä¹…é˜»å¡** | **panic**                          | é˜»å¡æˆ–æˆåŠŸå‘é€ |
| `<-ch`    | **æ°¸ä¹…é˜»å¡** | è¿”å›ç¼“å†²åŒºæ•°æ®ï¼›ç¼“å†²åŒºç©ºåˆ™è¿”å›é›¶å€¼ | é˜»å¡æˆ–æˆåŠŸæ¥æ”¶ |
| `close()` | **panic**    | **panic**                          | æˆåŠŸå…³é—­       |

**è®¾è®¡å‡†åˆ™**ï¼š

- åªç”±**å‘é€æ–¹**å…³é—­ Channelï¼Œä¸è¦åœ¨æ¥æ”¶æ–¹å…³é—­
- ä¸è¦å…³é—­ä¸€ä¸ªå·²ç»å…³é—­çš„ Channel
- ä¸è¦å‘ä¸€ä¸ªå·²ç»å…³é—­çš„ Channel å‘é€æ•°æ®

## å…«ã€select å¤šè·¯å¤ç”¨åŸç†

`select` æ˜¯ Channel çš„å¤šè·¯å¤ç”¨å™¨ï¼Œå…è®¸ä¸€ä¸ª goroutine åŒæ—¶ç­‰å¾…å¤šä¸ª Channel æ“ä½œï¼š

```go
select {
case v := <-ch1:
    fmt.Println("ä» ch1 æ”¶åˆ°", v)
case ch2 <- 42:
    fmt.Println("å‘é€åˆ° ch2")
case <-time.After(time.Second):
    fmt.Println("è¶…æ—¶")
default:
    fmt.Println("æ²¡æœ‰ Channel å°±ç»ª")
}
```

çœ‹ä¼¼ç®€å•çš„è¯­æ³•ï¼ŒèƒŒåæ˜¯ `runtime.selectgo` ä¸€ä¸ªç›¸å½“å¤æ‚çš„å‡½æ•°ã€‚

### ç¼–è¯‘å™¨è½¬æ¢

ç¼–è¯‘å™¨ä¼šå°† `select` è¯­å¥è½¬æ¢ä¸ºä¸åŒçš„è¿è¡Œæ—¶è°ƒç”¨ï¼š

| select å½¢æ€          | ç¼–è¯‘å™¨ä¼˜åŒ–                       |
| -------------------- | -------------------------------- |
| ç©º select `select{}` | ç›´æ¥è°ƒç”¨ `block()` æ°¸ä¹…é˜»å¡      |
| å• case + default    | è½¬æ¢ä¸º `if` + éé˜»å¡çš„ send/recv |
| å• case æ—  default   | è½¬æ¢ä¸ºæ™®é€šçš„ send/recv è°ƒç”¨      |
| å¤š case              | è°ƒç”¨ `runtime.selectgo`          |

### selectgo æ ¸å¿ƒé€»è¾‘

`selectgo` æ˜¯ select çš„æ ¸å¿ƒå®ç°ï¼Œå¤„ç†å¤š case çš„ä¸€èˆ¬æƒ…å†µã€‚å®ƒçš„æµç¨‹å¯ä»¥åˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µï¼š

**é˜¶æ®µä¸€ï¼šéšæœºè½®è¯¢**

```go
// ä¼ªä»£ç 
pollorder := randomPermutation(cases)  // å°† case éšæœºæ’åˆ—
```

**ä¸ºä»€ä¹ˆè¦éšæœºåŒ–ï¼Ÿ** ä¸ºäº†å…¬å¹³æ€§ã€‚å¦‚æœæ€»æ˜¯æŒ‰å›ºå®šé¡ºåºæ£€æŸ¥ï¼Œæ’åœ¨å‰é¢çš„ case ä¼šè¢«ä¼˜å…ˆé€‰ä¸­ï¼Œé€ æˆ**é¥¥é¥¿**â€”â€”åé¢çš„ case æ°¸è¿œå¾—ä¸åˆ°æ‰§è¡Œã€‚

**é˜¶æ®µäºŒï¼šç¡®å®šé”é¡ºåº**

```go
lockorder := sortByChannelAddress(cases)  // æŒ‰ Channel åœ°å€æ’åº
lockAllChannels(lockorder)                // æŒ‰é¡ºåºåŠ é”
```

**ä¸ºä»€ä¹ˆæŒ‰åœ°å€æ’åºåŠ é”ï¼Ÿ** å› ä¸º select å¯èƒ½æ¶‰åŠå¤šä¸ª Channelï¼Œéœ€è¦åŒæ—¶è·å–å¤šæŠŠé”ã€‚å¦‚æœä¸æŒ‰å›ºå®šé¡ºåºåŠ é”ï¼Œä¸¤ä¸ª goroutine çš„ select æ¶‰åŠç›¸åŒçš„ Channel æ—¶å¯èƒ½ä¼š**æ­»é”**ã€‚æŒ‰åœ°å€å‡åºåŠ é”æ˜¯ç»å…¸çš„æ­»é”é¢„é˜²ç­–ç•¥ã€‚

**é˜¶æ®µä¸‰ï¼šæ‰§è¡Œ**

```mermaid
flowchart TD
    Start["selectgo å¼€å§‹"] --> Lock["æŒ‰åœ°å€é¡ºåºé”å®šæ‰€æœ‰ Channel"]
    Lock --> Poll["æŒ‰éšæœºé¡ºåºéå†æ¯ä¸ª case"]
    Poll --> Ready{"æœ‰ case å°±ç»ª?"}
    
    Ready -->|"æ˜¯"| Execute["æ‰§è¡Œå°±ç»ªçš„ case<br/>è§£é”æ‰€æœ‰ Channel"]
    
    Ready -->|"å¦"| Default{"æœ‰ default?"}
    Default -->|"æ˜¯"| ExecDefault["æ‰§è¡Œ default<br/>è§£é”æ‰€æœ‰ Channel"]
    
    Default -->|"å¦"| Enqueue["ä¸ºæ¯ä¸ª case åˆ›å»º sudog<br/>æŒ‚å…¥å¯¹åº” Channel çš„ç­‰å¾…é˜Ÿåˆ—"]
    Enqueue --> Park["gopark é˜»å¡å½“å‰ goroutine"]
    Park --> Wakeup["æŸä¸ª Channel å°±ç»ª<br/>å½“å‰ goroutine è¢«å”¤é†’"]
    Wakeup --> Dequeue["ä»å…¶ä»–æ‰€æœ‰ Channel<br/>çš„ç­‰å¾…é˜Ÿåˆ—ä¸­ç§»é™¤ sudog"]
    Dequeue --> Return["è¿”å›è¢«å”¤é†’çš„ case"]
    
    style Execute fill:#b2f2bb
    style ExecDefault fill:#a5d8ff
    style Park fill:#ffc9c9
```

é˜¶æ®µä¸‰çš„å…³é”®ç»†èŠ‚ï¼š

1. **æŒ‰éšæœºé¡ºåº**éå†æ‰€æœ‰ caseï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥ç«‹å³æ‰§è¡Œ
2. å¦‚æœæœ‰å¤šä¸ª case åŒæ—¶å°±ç»ªï¼Œé€‰æ‹©éšæœºéå†ä¸­**ç¬¬ä¸€ä¸ªç¢°åˆ°çš„**
3. å¦‚æœæ²¡æœ‰ case å°±ç»ªä¸”æœ‰ `default`ï¼Œèµ° `default` åˆ†æ”¯
4. å¦‚æœæ²¡æœ‰ case å°±ç»ªä¸”æ²¡æœ‰ `default`ï¼š
   - ä¸º**æ¯ä¸ª case** åˆ›å»ºä¸€ä¸ª sudog
   - å°† sudog åˆ†åˆ«æŒ‚å…¥å„ä¸ª Channel çš„ `sendq` æˆ– `recvq`
   - è°ƒç”¨ `gopark` é˜»å¡
   - å½“ä»»ä¸€ Channel å°±ç»ªæ—¶ï¼Œå½“å‰ goroutine è¢«å”¤é†’
   - ä»**æ‰€æœ‰å…¶ä»– Channel** çš„ç­‰å¾…é˜Ÿåˆ—ä¸­ç§»é™¤è‡ªå·±çš„ sudogï¼ˆé˜²æ­¢é‡å¤å”¤é†’ï¼‰

è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä¸€ä¸ª goroutine åœ¨ select ä¸­ç­‰å¾… N ä¸ª Channel æ—¶ï¼Œä¼šåœ¨ N ä¸ªç­‰å¾…é˜Ÿåˆ—ä¸­åŒæ—¶å‡ºç°â€”â€”è¢«å”¤é†’åè¿˜éœ€è¦"æ¸…ç†ç°åœº"ã€‚

## ä¹ã€å¸¸è§çš„ Channel ä½¿ç”¨æ¨¡å¼

### æ¨¡å¼ä¸€ï¼šä¿¡å·é€šçŸ¥ï¼ˆDone Channelï¼‰

ç”¨æ— ç¼“å†²æˆ–å®¹é‡ä¸º 1 çš„ Channel ä¼ é€’"å®Œæˆ"ä¿¡å·ï¼š

```go
done := make(chan struct{}) // struct{} ä¸å å†…å­˜

go func() {
    defer close(done) // ä»»åŠ¡å®Œæˆæ—¶å…³é—­
    doWork()
}()

<-done // é˜»å¡ç­‰å¾…ä»»åŠ¡å®Œæˆ
```

`chan struct{}` æ˜¯æƒ¯ç”¨å†™æ³•â€”â€”ä¼ é€’çš„æ˜¯ä¿¡å·æœ¬èº«ï¼Œä¸éœ€è¦æºå¸¦æ•°æ®ï¼Œé›¶å­—èŠ‚ä¸æµªè´¹å†…å­˜ã€‚

### æ¨¡å¼äºŒï¼šè¶…æ—¶æ§åˆ¶

ç»“åˆ `select` å’Œ `time.After` å®ç°è¶…æ—¶ï¼š

```go
select {
case result := <-ch:
    fmt.Println("æ”¶åˆ°ç»“æœ:", result)
case <-time.After(3 * time.Second):
    fmt.Println("è¶…æ—¶!")
}
```

`time.After` è¿”å›ä¸€ä¸ª Channelï¼Œåœ¨æŒ‡å®šæ—¶é—´åå‘é€å½“å‰æ—¶é—´ã€‚é…åˆ selectï¼Œå¦‚æœä¸» Channel åœ¨ 3 ç§’å†…æ²¡æœ‰æ•°æ®ï¼Œå°±èµ°è¶…æ—¶åˆ†æ”¯ã€‚

### æ¨¡å¼ä¸‰ï¼šé™æµå™¨ï¼ˆSemaphoreï¼‰

æœ‰ç¼“å†² Channel å¤©ç„¶å°±æ˜¯ä¸€ä¸ª**è®¡æ•°ä¿¡å·é‡**ï¼š

```go
sem := make(chan struct{}, 10) // æœ€å¤šå…è®¸ 10 ä¸ªå¹¶å‘

for _, task := range tasks {
    sem <- struct{}{} // è·å–ä»¤ç‰Œï¼ˆæ»¡äº†å°±é˜»å¡ï¼‰
    go func(t Task) {
        defer func() { <-sem }() // å½’è¿˜ä»¤ç‰Œ
        process(t)
    }(task)
}
```

ç¼“å†²åŒºå®¹é‡å°±æ˜¯æœ€å¤§å¹¶å‘æ•°ã€‚æ»¡äº†å°±é˜»å¡ç­‰å¾…ï¼Œæœ‰äººå®Œæˆé‡Šæ”¾ä½ç½®åæ‰èƒ½ç»§ç»­ã€‚

### æ¨¡å¼å››ï¼šnil Channel åŠ¨æ€å¼€å…³

`nil` Channel çš„ç‰¹æ®Šè¡Œä¸ºï¼ˆæ°¸ä¹…é˜»å¡ï¼‰åœ¨ `select` ä¸­æœ‰å¦™ç”¨â€”â€”åŠ¨æ€ç¦ç”¨æŸä¸ª caseï¼š

```go
var ch1, ch2 <-chan int
ch1 = producer1()
ch2 = producer2()

for ch1 != nil || ch2 != nil {
    select {
    case v, ok := <-ch1:
        if !ok {
            ch1 = nil // å…³é—­åè®¾ä¸º nilï¼Œæ­¤ case æ°¸è¿œä¸å†è¢«é€‰ä¸­
            continue
        }
        process(v)
    case v, ok := <-ch2:
        if !ok {
            ch2 = nil
            continue
        }
        process(v)
    }
}
```

å°† Channel å˜é‡è®¾ä¸º `nil` åï¼Œå¯¹åº”çš„ select case åœ¨ä¸‹æ¬¡å¾ªç¯ä¸­ä¼šè¢«è‡ªåŠ¨"ç¦ç”¨"ï¼ˆå› ä¸ºå¯¹ nil Channel æ“ä½œæ°¸è¿œé˜»å¡ï¼Œselect æ°¸è¿œä¸ä¼šé€‰ä¸­å®ƒï¼‰ï¼Œæ— éœ€ä¿®æ”¹ select ç»“æ„ã€‚

### æ¨¡å¼äº”ï¼šæ‰‡å…¥ï¼ˆFan-inï¼‰

å°†å¤šä¸ª Channel çš„æ•°æ®æ±‡èšåˆ°ä¸€ä¸ª Channelï¼š

```go
func fanIn(channels ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for v := range c {
                out <- v
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(out) // æ‰€æœ‰è¾“å…¥ Channel å…³é—­åï¼Œå…³é—­è¾“å‡º Channel
    }()
    
    return out
}
```

æ¯ä¸ªè¾“å…¥ Channel ç”±ä¸€ä¸ªç‹¬ç«‹çš„ goroutine è¯»å–å¹¶è½¬å‘åˆ°è¾“å‡º Channelï¼Œæœ€ç»ˆæ‰€æœ‰è¾“å…¥å…³é—­åè¾“å‡ºä¹Ÿéšä¹‹å…³é—­ã€‚

## åã€æ€§èƒ½ç‰¹å¾ä¸æœ€ä½³å®è·µ

### Channel çš„å¼€é”€åœ¨å“ªé‡Œ

| æ“ä½œ           | å¼€é”€æ¥æº                      |
| -------------- | ----------------------------- |
| æ¯æ¬¡ send/recv | äº’æ–¥é”åŠ é”/è§£é”               |
| æ•°æ®ä¼ é€’       | è‡³å°‘ä¸€æ¬¡ `memmove`ï¼ˆå€¼æ‹·è´ï¼‰  |
| é˜»å¡/å”¤é†’      | `gopark`/`goready` æ¶‰åŠè°ƒåº¦å™¨ |
| select å¤š case | å¤šä¸ªé”çš„è·å–/é‡Šæ”¾ï¼Œsudog åˆ†é… |

Channel ä¸æ˜¯é›¶å¼€é”€çš„æŠ½è±¡ã€‚åœ¨æç«¯é«˜æ€§èƒ½åœºæ™¯ä¸‹ï¼ˆå¦‚æ¯ç§’åƒä¸‡æ¬¡æ“ä½œï¼‰ï¼ŒChannel çš„é”ç«äº‰å¯èƒ½æˆä¸ºç“¶é¢ˆï¼Œæ­¤æ—¶å¯èƒ½éœ€è¦è€ƒè™‘ `sync/atomic` æˆ–æ— é”æ•°æ®ç»“æ„ã€‚

### é€‰å‹å»ºè®®

| åœºæ™¯                        | æ¨èæ–¹æ¡ˆ              |
| --------------------------- | --------------------- |
| goroutine é—´ä¼ é€’æ•°æ®æ‰€æœ‰æƒ  | Channel               |
| ä¿æŠ¤å…±äº«æ•°æ®ç»“æ„            | `sync.Mutex`          |
| ç®€å•çš„è®¡æ•°å™¨/æ ‡å¿—ä½         | `sync/atomic`         |
| å¤šä¸ª goroutine ç­‰å¾…åŒä¸€äº‹ä»¶ | `close(channel)` å¹¿æ’­ |
| éœ€è¦å–æ¶ˆ/è¶…æ—¶æ§åˆ¶           | `context.Context`     |

## åä¸€ã€æ€»ç»“

æœ¬æ–‡ä» Channel çš„åŸºç¡€ç”¨æ³•å‡ºå‘ï¼Œé€å±‚æ·±å…¥åˆ° Runtime å®ç°å±‚é¢ï¼š

| å±‚æ¬¡     | å†…å®¹                                                             |
| -------- | ---------------------------------------------------------------- |
| **è¡¨é¢** | `make`ã€`<-`ã€`close`â€”â€”ç®€æ´çš„è¯­æ³•ç³–                              |
| **ç»“æ„** | `hchan` = ç¯å½¢ç¼“å†²åŒº + ä¸¤ä¸ªç­‰å¾…é˜Ÿåˆ— + äº’æ–¥é”                     |
| **æµç¨‹** | å‘é€/æ¥æ”¶å„ä¸‰æ¡è·¯å¾„ï¼šç›´æ¥ä¼ é€’ â†’ ç¼“å†²åŒº â†’ é˜»å¡                    |
| **è°ƒåº¦** | `gopark` è®©å‡º CPUï¼Œ`goready` é‡å›è¿è¡Œé˜Ÿåˆ—â€”â€”ä¸ GMP è°ƒåº¦å™¨æ·±åº¦é›†æˆ |
| **å¤šè·¯** | `selectgo` ç”¨éšæœºè½®è¯¢ä¿è¯å…¬å¹³ï¼Œç”¨åœ°å€æ’åºé¢„é˜²æ­»é”                |

Channel çš„è®¾è®¡ä½“ç°äº† Go ä¸€è´¯çš„å·¥ç¨‹å“²å­¦ï¼š**æ¥å£ç®€å•ï¼Œå†…éƒ¨ç²¾å·§**ã€‚è¡¨é¢ä¸Šä½ åªéœ€è¦ `<-` ä¸€ä¸ªç®­å¤´ï¼ŒèƒŒå Runtime å¸®ä½ å¤„ç†äº†é”ã€è°ƒåº¦ã€å†…å­˜æ‹·è´ã€GC åä½œç­‰æ‰€æœ‰å¤æ‚æ€§ã€‚

ç†è§£è¿™äº›åº•å±‚æœºåˆ¶ï¼Œä¸æ˜¯ä¸ºäº†è‡ªå·±é‡å†™ä¸€ä¸ª Channelï¼Œè€Œæ˜¯ä¸ºäº†åœ¨é‡åˆ°å¹¶å‘é—®é¢˜æ—¶â€”â€”æ— è®ºæ˜¯æ€§èƒ½ç“¶é¢ˆã€æ­»é”æ’æŸ¥ã€è¿˜æ˜¯æ¶æ„é€‰å‹â€”â€”èƒ½å¤Ÿåšå‡ºæœ‰æ®å¯ä¾çš„åˆ¤æ–­ã€‚
